자료구조 : 자료를 다루기위해 사용되는 여러가지 구조 (ex : 스택, 큐, 트리, 그래프 ... )

선형 자료구조 (linear Data structure) : 일렬로 나열하여 저장하는데, 자료들 사이에는 순서가 존재.
비션형 자료구조 (Non-linear Data structure) : 한줄로 세우기 어려운 관계의 자료

알고리즘(Algorithm) : 문제를 해결하는 절차. 이때 데이터는 자료구조로 표현되어짐.

결국 프로그램은 자료구조와 알고리즘으로 구성되어있음.
알고리즘의 조건.
1. 0개 이상의 입력, 1개 이상의 출력이 존재하여야한다.
2. 명백성 : 각 명령어의 의미는 모호하지않고 명확해야한다.
3. 유한성 : 한정된 수의 단계 후에는 반드시 종료되어야한다.
4. 유효성 : 각 명령어들은 실행 가능한 연산이어야 한다.

추상자료형 (Abstract Data Type) : 
자료구조가 어떤 자료를 다루고있는지, 어떤 연산이 제공되는지 기술.

알고리즘의 성능분석
알고리즘의 복잡도 분석 : 알고리즘의 연산횟수를 대략적으로 계산, 연산량이 크면 더 복잡한 알고리즘이 된다.
복잡도를 구하기위해선 얼마나 많은 연산이 실행되는지 계산해야한다.
연산들의 실행 횟수는 입력의 크기 n에 대한 함수형태 즉 T(n)으로 나타낸다.

![image](https://github.com/d982h8st7/Datastructure_study/assets/50827253/eb59e7d8-4604-4c57-8dce-2a6ae4a452c0)

T(n)1 = 2n
T(n)2 = 4

입력의 크기가 커질때마다 연산의 수가 증가함을 볼수있다.

복잡도의 점근적 표기

알고리즘의 복잡도는 2n+1을 n으로 표현하고 8n^2 + 2n + 17을 n^2으로 단순화시켜 사용한다.
그 이유는
ex ) T1(n) = 4000n + 2000000 , T2(n) = n^2 + 2n
![image](https://github.com/d982h8st7/Datastructure_study/assets/50827253/fa464f22-1f59-4b03-95f0-6e3efebcaae3)

어느순간부터 T2의 연산량이 T1보다 커지게된다.
즉, n이 커지면 커질수록 계수들은 영향이 줄어들고 최고차항의 영향이 커지는것이다.
이러한 이유로 알고리즘의 복잡도를 설명할 때 최고차항만을 계수없이 취해 단순하게 표현한다.
그러므로 정확한 연산량이 아니라 연산량이 얼마나 빨리 증가하는가 만을 나타내는것이다.

빅오 표기법(Big-O) 

알고리즘의 복잡도를 O(g(n))으로 표현하는데 증가속도가 g(n)과 같거나 낮은 모든 복잡도 함수를 포함한다는 의미.
ex) 2n+1 = O(n) 증가속도가 n과 같기때문에 2n+1은 O(n)이다 라고 말할수있다.
반대로 0.000001n^3 인 알고리즘은 아무리 계수가 작아지더라도 증가속도가 n^2 < n^3 이기떄문에
절대로 O(n^2)에 속할수없다.
따라서 빅오는 처리시간의 상한을 의미한다.

빅 오메가 (Big-Ω) 표기법
증가속도가 g(n)과 같거나 높은 모든 복잡도 함수를 포함. 하한을 의미. 예를들어 Ω(n^2)는 아무리 빨리 처리하더라도
n^2이상의 시간이 반드시 걸린다 라는것을 의미

빅 세타(Big-θ) 표기법 
증가속도가 g(N)과 같은 복잡도 함수들만을 포함한다. 상한인 동시에 하한인 경우를 말한다.

만약 시간복잡도를 정확히 계산할수있다면, 빅세타 표기법을 사용하는 것이 좋고, 정확히 분석하기 어렵다면 상한을 구해
빅오 표기법으로 나타내거나 하한을 구해 빅오메가 표기법으로 나타낸다.
일반적으로는 최악의 상황을 고려한 해결책을 찾기때문에 빅오 표기법이 주로 사용됨.

```py
import random

def search(a, key):
    n = len(a)
    count = 0
    for i in range(n):
        count += 1
        if a[i] == key:
            print(f"연산 횟수: {count}")
            return i
    print(f"연산 횟수: {count}")
    return -1

arr = list(range(1, 11))
random.shuffle(arr)

key = 7
print(f"배열: {arr}")
print(search(arr, key))

```

코드에서 볼수있듯 입력의 크기가 같더라도 입력의 구성이 다르면 처리시간이 달리진다.
즉 최선,최악,평균의 효율성이 서로 다르다.

시간 복잡도 분석 : 순환(Recursion) 알고리즘
순환 : 어떤 함수가 자기 자신을 다시 호출하여 문제를 해결하는 프로그래밍 기법

```py
def factorial(n, count=0):
    count += 1
    if n == 1:
        return 1, count
    else:
        value, count = factorial(n-1, count)
        return n * value, count

n = 10
result, operation_count = factorial(n)
print(f"{n}! = {result}")
print(f"연산 횟수: {operation_count}")

```
시간 복잡도는 O(n)이다.


