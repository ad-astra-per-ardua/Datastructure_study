# 자료구조란

프로그래밍에서는 자료(data)를 정리 및 보관을 하기위해 여러가지 구조들이 사용된다. 이를 자료구조(data structure)라고 부른다. 자료구조의 종류에는 스택, 큐, 트리, 그래프등이 있다.

#### 자료구조의 분류

- 선형 자료구조 : 자료들을 일렬로 나열하게 저당된다. 종류로는 리스트, 스택, 큐, 덱이 있다.
- 비선형 자료구조 : 한 줄로 세우기 어려운 복잡한 관계의 자료들을 표현할 수 있다. 종류로는 트리, 그래프가 있다

# 알고리즘이란

    알고리즘이란 어떤 문제를 해결하는 절차를 알고리즘이라고 한다. 자료구조는 자료를 이용하고 표현하기 위해 사용된다고 했었다. 그러면 결국 프로그램은 자료구조와 알고리즘으로 구성되어 있다고 볼 수 있다.

#### 알고리즘 조건

- 입력 : 0개 이상의 입력이 존재
- 출력 : 1개 이상의 출력이 존재
- 명백성 : 각 명령어의 의미는 모호하지 않고 명확해야 한다.
- 유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 한다.
- 유효성 : 각 명령어들은 실행 가능한 연산이어여 한다.

# 추상 자료형(ADT)

사용자 프로그램에게는 구현에 관한 세부사항들을 감추고 간단한 인터페이스(interface)만을 공개한다. 즉, A라는 자료구조가 있다고 하면 사용자는 A가 어떻게 구현되었지 몰라도 공개된 인터페이스만을 이용해 쉽게 사용할 수 있다.

##### 가방을 추상 자료형을 정의하고 구현해보자

- insert(e) : 가방에 항목 e를 넣는다.
- remove(e) : 가방에 e가 있는지 확인 후 있으면 삭제
- contains(e) : e가 있으면 True 없으면 False
- count() : 가방에 들어 있는 항목들의 수를 반환

```python
# e가 있는지 확인 있으면 True없으면 False
def contains(bag, e) :
	return e in bag

# e를 가방안에 넣음
def insert(bag, e) :
	bag.append(e)

# e를 가방 안에서 꺼내자
def remove(bag, e) :
	bag.remove(e)

# 가방안에는 몇개의 물건이 있는가?
def count(bag) :
	return leg(bag)
```

# 알고리즘의 성능 분석

#### 실행시간

좋은 알고리즘은 실행시간이 짧으면서 메모리와 같은 물리적 자원들이 적게 사용되는 것이다. 일반적으로 메모리 공간 보다 실행시간을 효율적인 알고리즘의 기준으로 삼는다.
그러면 알고리즘 효율성은 어떻게 판단할 수 있을까? 가장 확실한 방법은 알고리즘을 구현하고 실제로 컴퓨터 실행시키고, 실행시간을 측정하는 것이다.

파이썬에서는 다음과 같이 알고리즘의 실행시간을 측정 할 수 있다. 아까 가방 추상 자료형을 구현한 것을 쓰겠다.

```python
# 시간 측정을 위해 time 모튤을 import
import time

myBag = []
# 현재시간을 start 변수에 넣는다.
start = time.time()

insert(myBag, "농구공")
...

# 코드가 끝나는 시점
end = time.time()
# 전체 실행시간
print("실행시간 = ", end - start)
```

이런한 시간 측정은 매우 직관적이고 간단하지만 중요한 문제점이 있다.

- 반드시 "구현"되어야 됨
- 반드시 동일한 하드웨어를 사용해야됨 비효율적인 알고리즘도 좋은 컴퓨터에서 실행하면 더 빨리 처리 될 수 있다.
- 소프트웨어 환경도 동일해야됨. python보다 C나 C++와 같은 컴파일 방식 언어를 사용한 방식이 더 빠르기 때문이다.
- 다른 데이터를 사용시 다른 결과가 나올 수 있다.
  그러면 구현하지도 않고 알고리즘을 효율성을 따져보는 방법은 없을까? 그 방법은 다음에 설명하는 복잡도 분석이다.

#### 복잡도 분석

복잡도 분석은 구현하지 않고 알고리즘의 효율성을 평가하는 방법이다. 처리시간을 직접 구현하는것이 아닌 알고리즘의 연산 횟수를 대략적으로 계산하는 것이다.
예를 들어, 자연수 1부터 n까지의 합을 구하는 두 가지 알고리즘이 있다고 해보자.

```python
calc_sum1(n)
 sum <- 0;
 for i to n then
	 sum <- sum + i
 return sum
```

다른 방법이다.

```python
calc_sum2(n)
	sum <- n * (n+1) / 2
	return sum
```

이제 이들 알고리즘을 분석해 보자. 알고리즘 복잡도를 구하기 위해서는 연산이 얼마나 실행되었는지를 계산해야된다. 보통 입력 크기 n에 대한 함수 형태 T(n)으로 나타나는데, 이를 <b>복잡도 함수</b>라고 한다. 두 알고리즘을 살펴보며 복잡도 함수를 계산해보자.

- 알고리즘 1번째 : 2행에서 대입연산 (sum <- 0)아 한번 수행된다 반목문 내부인 4행에서는 (sum <- sum + i)은 n번 수행된다. 대입과 덧셈 연산을 한 번 씩 수행한다. 단순화를 위해 반복제어와 반환 연산자는 무시하자. 이들은 복잡도에 영향을 주지 않는다. 2행과 4행을 실행 횟수를 모두 합하면 2n + 1이되고, 따라서 이 알고리즘은 복잡도 함수는 T(n) = 2n + 1로 나타낼수 있다.
- 알고리즘 2번째 : 한번만 수행되는 2행에는 여러 연산이 사용된다. (sum <- n \* (n+1) / 2) 대입, 곱셈, 덧셈, 나눗셈 연산z이 한 번 씩 수행된다. 따라서 3행을 제외하고 총 4번의 연산이 필요하므로 T(n) = 4이다.

알고리즘 2번째는 입력의 크키 n과 관계없이 같은 연산을 수행한다. 하지만 1번째는 n에 비례하는 수의 연산이 발생한다. 여기서 우리는 생각할 수 있다. n이 커질수록 2번째 효율적이라는 것을 이것이 복잡도 분석의 핵심이다.

#### 복잡도의 점금적 표기

알고리즘의 복잡도는 흔히 더 간단한 형태로 단순화시켜 사용한다. 예를 들어 $$T(n) = 65536n + 2000000$$$$T(n) = n^2 + 2n$$이라는 복잡도 함수가 있다. 어느 것이 더 좋은 알고리즘일까?
얼핏 보면 첫번째가 더 비효율적 보일 수도 있다. 하지만 입력의 크기를 극대화 시키면 어떻게 될까?
![[스크린샷 2023-09-27 오전 12.54.36.png]]
n이 작을때는 알고리즘 A가 효율적이다. 하지만 n이 커지수록 B가 더 비효율적이다.
이런씩으로 <u>여러 항을 갖는 복잡도 함수를 최고차항만을 게수 없이 취해 단순하게 표현하는 방법을 접근적 표기라고한다.</u>

#### 빅오(big-O) 표기법

빅오 표기법은 알고리즘 복잡도를 O(g(n))과 같이 나타내는데, 이것은 증가속도가 g(n)과 같거나 낮은 모든 복잡도 함수를 모두 포함한다. 예를 들어 2n + 1이면 , O(n)에 속한다 라고 말할 수 있다. 또는 $$O(n^2)$$은 어떤 경우에도 n제곱에 비례하는 시간 안에는 반드시 완료된다는 것을 뜻한다. n제곱보다는 더 빨리 처리 될 수 있지만 절대로 그보다 시간이 더 걸릴 수는 없다. 따라서 빅오의 처리시간의 <b>상한(upper bound)</b>을 의미한다.

#### 빅오메가(big-omega) 표기법

$$\omega(g(n)) 증가속도가 g(n)과 같거나 높은 모든 복잡도 함수를 포함하는데, 복잡도 함수의 하한을 의미한다. $$

#### 빅세타(big theta) 표기법

$$\theta(g(n))은 증가속도가 g(n)과 같은 복잡도 함수들만을 포함한다.$$

다음은 자주 사용하는 빅오 표기의 수행간 순서대로 나열한 것이다.
$$ O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(n!)$$

# 성능 차이

대부분의 경우 알고리즘에 최대한 불리한 입력 데이터를 사용하는 최악의 경우의 실행시간이 가장 중요하다

# 순환이란

순환이란 어떤 함수가 자기 자신을 다시 호출하는 프로그래밍 기법이다. 다른 언어 책에는 재귀함수라고 부른다.
순환의 개념은 많은 효율적인 알고리즘들에서 사용되는 매우 중요한 개념이다.

#### 순환 구조의 팩토리얼 함수

```python
def factorial(n):
	if n == 1:
		reuturn 1
	else :
		return n * factorial(n - 1)
```

순환 함수는 자신을 순환적으로 호출하는 부분과 순환 호출을 멈추는 부분으로 구성되어 있다. factorial(3) 호출 되었을때 return n _ factorial(n - 1)이 순환적으로 호출되다가 if n == 1; 부분에서 1!이 되어 1을 반환한다.
1을 반환한 factorial( )은 전에 호출되었던 함수에가서 return 6 _ 1이되고 전에 받았던 6을 반환한다.
